<resources>
    <string name="app_name">CoroutinesExample</string>
    <string name="logTitle">Лог</string>
    <string name="loClearButton">Очистить</string>
    <string name="buttonGo">Перейти</string>
    <string name="autoscrollOn">Выкл автоскролл</string>
    <string name="autoscrollOff">Вкл автоскролл</string>
    <string name="openExample">Открыт пример: %1$s</string>
    <string name="quitExample">Закрыт пример: %1$s</string>
    <string name="titleDispatchers">Диспетчеры</string>
    <string name="dispatchersCase1">Дефолтный диспетчер. Смотрим какой диспетчер создается без явного указания диспетчера</string>
    <string name="dispatchersCase2">Дефолтный диспетчер. Смотрим сколько максимум одновременных потоков может быть при использовании дефолтного диспетчера</string>
    <string name="dispatchersCase3">IO диспетчер. Смотрим сколько максимум одновременных потоков может быть при использовании IO диспетчера</string>
    <string name="dispatchersCase4">Создание собственного диспетчера с одним потоком</string>
    <string name="dispatchersCase5">Unconfined диспетчер. Особенности работы</string>
    <string name="titleErrors">Ошибки</string>
    <string name="errorsCase1">Отмена скоупа и всех дочерних корутин при ошибке внутри try-catch внутри дочерней корутины</string>
    <string name="errorsCase2">Обработчик ошибок вместо try-catch</string>
    <string name="errorsCase3">Обработчик ошибок + SupervisorJob в скоупе</string>
    <string name="errorsCase4">Обработчик ошибок + SupervisorJob в корутине. Несколько корутин на одном уровне</string>
    <string name="errorsCase5">Билдер launch + async корутина + await. Проверка что не выполняется код после await при возникновении ошибки</string>
    <string name="errorsCase6">Билдер launch + async корутина + await. Используем try-catch, проверяем что после await при возникновении ошибки код выполняется</string>
    <string name="errorsCase7">Ошибка в suspend функции корутины. Try-catch</string>
    <string name="titleBuilders">Билдеры</string>
    <string name="buildersCase1">Билдер async. Получаем результат методом await</string>
    <string name="buildersCase2">Билдер launch. Запуск дочерних корутин так, чтобы родительская не дожидалась их завершения и так, чтобы дожидалась.</string>
    <string name="buildersCase3">Билдер async. Запуск дочерних корутин с получением от них результата, параллельный запуск.</string>
    <string name="buildersCase4">Билдеры launch и async. Ленивый старт корутины</string>
    <string name="titleSuspend">Suspend функции</string>
    <string name="suspendCase1">Проверяем то что suspend функция не блокирует поток</string>
    <string name="titleCoroutines">Корутины</string>
    <string name="coroutinesCase1">ЖЦ корутины</string>
    <string name="coroutinesCase2">Неправильная отмена корутины</string>
    <string name="coroutinesCase3">Правильная отмена корутины</string>
    <string name="coroutinesCase4">Дожидаемся выполнения корутины с помощью join</string>
    <string name="coroutinesCase5">Параллельная работа внутри родительской корутины с использованием join</string>
    <string name="coroutinesCase6">Ленивое создание корутины</string>
    <string name="coroutinesCase7">Отмена корутины + invokeOnCancellation</string>
    <string name="coroutinesCase8">Используем NonCancellableJob</string>
    <string name="coroutinesCase9">Параллельный запуск корутин</string>
    <string name="coroutinesCase10">Работа с одной переменной разными способами</string>
    <string name="coroutinesCase11">Наследование в корутинах</string>
    <string name="coroutinesCase12">Защита от повторных вызовов с помощью Job</string>
    <string name="coroutinesCase13">Проверяем что родительская корутина ждет завершения дочерней</string>
    <string name="titleScope">Скоуп</string>
    <string name="scopeCase1">Отмена скоупа вместе с его корутинами</string>
    <string name="scopeCase2">Создаем иерархию корутин и отменяем их по-разному, смотрим что происходит</string>
    <string name="scopeCase3">Создаем свой объект и добавляем его в контекст скоупа</string>
    <string name="scopeCase4">Проверяем что контекст передается корутинам по наследству + меняем контекст при создании дочерней корутины</string>
    <string name="titleScopeFunctions">Скоуп функции</string>
    <string name="scopeFunctionsCase1">Создаем и отменяем корутины</string>
    <string name="scopeFunctionsCase2">Создаем и отменяем корутины + SupervisorScope</string>
    <string name="scopeFunctionsCase3">Используем withContext для замены контекста</string>
    <string name="scopeFunctionsCase4">Используем runBlocking чтобы заблокировать поток</string>
    <string name="scopeFunctionsCase5">Используем viewmodelScope</string>
    <string name="scopeFunctionsCase6">Используем lifecycleScope</string>
    <string name="scopeFunctionsCase7">Используем mainScope</string>
    <string name="scopeFunctionsCase8">Создаем свой скоуп</string>
    <string name="titleChannels">Каналы</string>
    <string name="channelsCase1">Самое просто использование канала. Одной корутиной складываем, второй достаем</string>
    <string name="channelsCase2">Складываем в канал больше чем могут получить</string>
    <string name="channelsCase3">Складываем в канал меньше чем могут получить</string>
    <string name="channelsCase4">Закрываем канал и ловим ексепшн от этого</string>
    <string name="channelsCase5">Заворачиваем получение из канала в цикл, смотрим что получится</string>
    <string name="channelsCase6">Закрываем канал и используем isClosedForReceive</string>
    <string name="channelsCase7">Увеличиваем размер канала через capacity</string>
    <string name="channelsCase8">Увеличиваем размер канала через Channel.Factory.CONFLATED</string>
    <string name="channelsCase9">Отменяем канал</string>
    <string name="channelsCase10">Отменяем корутину, но не канал</string>
    <string name="channelsCase11">Закрываем канал при отмене корутины через колбек invokeOnCompletion</string>
    <string name="channelsCase12">Используем канал несколькими корутинами</string>
    <string name="channelsCase13">Пробуем слать в канал через trySend</string>
    <string name="titleFlow">Флоу</string>
    <string name="flowCase1">Создаем стандартный флоу, проверяем холодность</string>
    <string name="flowCase2">Создаем стандартный флоу через asFlow</string>
    <string name="flowCase3">Создаем стандартный флоу через flowOf</string>
    <string name="flowCase4">Создаем стандартный флоу через ::fun :Something</string>
    <string name="flowCase5">Создаем свой флоу под многие из intermediate операторов</string>
    <string name="flowCase6">Создаем свой оператор</string>
    <string name="flowCase7">Смотрим что делает метод emitAll</string>
    <string name="flowCase8">Создаем свой флоу под многие из terminal операторов</string>
    <string name="flowCase9">Создаем свой флоу под onEach, onStart, onCompletion, onEmpty</string>
    <string name="flowCase10">Создаем channelFlow</string>
    <string name="flowCase11">Создаем callbackFlow</string>
    <string name="flowCase12">Используем оператор flowOn</string>
    <string name="flowCase13">Используем оператор buffer</string>
    <string name="flowCase14">Используем оператор produceIn</string>
    <string name="flowCase15">Используем оператор catch</string>
    <string name="flowCase16">Используем оператор retry</string>
    <string name="flowCase17">Используем оператор retryWhen</string>
    <string name="flowCase18">Отмена флоу + try-catch</string>
    <string name="flowCase19">Создаем SharedFlow</string>
    <string name="flowCase20">Создаем StateFlow</string>
    <string name="flowCase21">Проверяем параметры shareIn у SharedFlow</string>
    <string name="flowCase22">Проверяем параметры subscriptionCount у SharedFlow</string>
    <string name="flowCase23">Проверяем режимы работы onBufferOverflow у SharedFlow</string>
    <string name="flowCase24">Проверяем параметр extraBufferCapacity у SharedFlow</string>
    <string name="flowCase25">Проверяем параметр replay у SharedFlow</string>
    <string name="flowCase26">Проверяем что корутина приостанавливается пока ждет следующий элемент флоу</string>
    <string name="titleOperators">Операторы</string>
    <string name="operatorsCase1">Используем оператор select</string>
    <string name="operatorsCase2">Используем оператор actor</string>
    <string name="dispatchersCase1WithoutDispatcherDesc">Скоуп создан без указания диспетчера, используется диспетчер по умолчанию (DEFAULT), видим что используются треды DefaultDispatcher</string>
    <string name="dispatchersCase1WithDispatcherDesc">Скоуп создан с указанием main диспетчера, видим что используется main тред</string>
    <string name="dispatchersCase1Action1">Скоуп создан</string>
    <string name="dispatchersCase1Action2">Запущена корутина в скоупе</string>
    <string name="dispatchersCase1Action3">Содержимое контекста скоупа: %1$s</string>
    <string name="dispatchersCase1Action4">Текущий тред: %1$s</string>
    <string name="dispatchersCase1Title">Если при создании корутины или скоупа диспетчер не указан, то используется дефолтный.</string>
    <string name="dispatchersCase1ButtonWithout">Создать скоуп без указания диспетчера</string>
    <string name="dispatchersCase1ButtonWith">Создать скоуп с диспетчером Main</string>
    <string name="dispatchersCase2Title">Создаем одновременно 20 корутин с Default диспетчером. Потоков будет столько, сколько ядер на устройстве (считая виртуальные). Каждая корутина будет делать ⅓ от своей работы за 2 секунды, и выполнив всю работу на 100% завершаться. Так будет повторяться, пока не выполнят свою работу все 20 корутин.</string>
    <string name="dispatchersCase2Button">Создать одновременно 20 корутин</string>
    <string name="dispatchersCase2Action1">Корутина %1$d запущена в треде %2$s в %3$s</string>
    <string name="dispatchersCase2Action2">Корутина %1$d сделала 1/3 работы в треде %2$s в %3$s</string>
    <string name="dispatchersCase2Action3">Корутина %1$d сделала 2/3 работы в треде %2$s в %3$s</string>
    <string name="dispatchersCase2Action4">Корутина %1$d завершена в треде %2$s в %3$s</string>
    <string name="dispatchersCase2Action5">Видим, что одновременно работает ограниченное число корутин. Только после того, как поток освободится, он возьмет в работу следующую корутину.</string>
    <string name="dispatchersCase3Title">Создаем одновременно 100 корутин, смотрим сколько одновременно работает на счетчике ниже и сверяемся с логом. Каждая корутина работает 5 секунд и завершается.</string>
    <string name="dispatchersCase3Button">Создать одновременно 100 корутин</string>
    <string name="dispatchersCase3Counter">Счетчик активных задач у джоба: </string>
    <string name="dispatchersCase3Action1">Корутина %1$d запущена в треде %2$s в %3$s</string>
    <string name="dispatchersCase3Action2">Корутина %1$d завершена в треде %2$s в %3$s</string>
    <string name="dispatchersCase3Action3">После нажатия кнопки активных задач становится 100, потому что мы одновременно создаем их 100. Но выполняется одновременно скорее всего только 64, поэтому после выполнения первой пачки счетчик меняется на 36. И последняя смена на 1 происходит из-за добавления этой текстовки, которая срабатывает по колбеку, когда у джоба заканчиваются активные задачи.</string>
    <string name="dispatchersCase4Title">Создать 5 корутин, которые будут выполняться в созданном нами диспетчере, имеющим в распоряжении только один поток. Время работы одной корутины составляет 1 секунду.</string>
    <string name="dispatchersCase4Button">Создать</string>
    <string name="dispatchersCase4Action1">Корутина %1$d запущена в треде %2$s в %3$s</string>
    <string name="dispatchersCase4Action2">Корутина %1$d завершена в треде %2$s в %3$s</string>
    <string name="dispatchersCase4Action3">Видим, что одновременно работает только одна корутина.</string>
    <string name="dispatchersCase5Title">Создаем корутину и смотрим как меняется поток выполнения при использовании диспетчера Unconfined.</string>
    <string name="dispatchersCase5ButtonMain">Создать с диспетчером мейн</string>
    <string name="dispatchersCase5ButtonUnconfined">Создать с диспетчером unconfined</string>
    <string name="dispatchersCase5Action1">Запустили корутину с Unconfined диспетчером в треде %1$s в %2$s</string>
    <string name="dispatchersCase5Action2">Запускаем суспенд функцию из корутины в треде %1$s в %2$s</string>
    <string name="dispatchersCase5Action3">Корутина завершилась в треде %1$s в %2$s</string>
    <string name="dispatchersCase5Action4">Запустилась суспенд функция в треде %1$s в %2$s</string>
    <string name="dispatchersCase5Action5">Суспенд функция подождала секунду ДО смены потока в треде %1$s в %2$s</string>
    <string name="dispatchersCase5Action6">Суспенд функция подождала секунду ПОСЛЕ смены потока на IO в треде %1$s в %2$s</string>
    <string name="dispatchersCase5Action7">Суспенд функция завершилась в треде %1$s в %2$s</string>
    <string name="dispatchersCase5Action8">Продолжение работы корутины после выполнения суспенд функции в треде %1$s в %2$s</string>
    <string name="dispatchersCase5Action9">Видим, что корутина стартует в main, так как билдер, запустивший и создавший корутину находится в нем. Далее во время выполнения суспенд функции уходим в другие потоки, а после возвращения остаемся в них же, уйдя из мейн в суспенд функции.</string>
    <string name="dispatchersCase5Action10">Видим, что корутина стартует в main (явно указали диспетчер main). Далее во время выполнения суспенд функции уходим в IO поток, а после возвращаемся в main.</string>
    <string name="dispatchersCase5Action11">Запустили корутину с Main диспетчером в треде %1$s в %2$s</string>
    <string name="suspendsCase1Title">По кнопке А запускаем суспенд функцию в мейн потоке, которая выполняет длительную работу (просто ждет 10 сек). По кнопке Б меняем UI, тем самым видим что суспенд функция не блокирует поток, а именно приостанавливает выполнение своего кода.</string>
    <string name="suspendsCase1ButtonA">Стартануть долгую суспенд функцию</string>
    <string name="suspendsCase1ButtonB">Поменять квадратик</string>
    <string name="suspendsCase1Action1">Суспенд функция стартанула в треде %1$s в %2$s</string>
    <string name="suspendsCase1Action2">Суспенд функция завершилась в треде %1$s в %2$s</string>
    <string name="buildersCase1Title">Создаем корутину билдером async и получаем результат</string>
    <string name="buildersCase1Button">Создать корутину билдером async</string>
    <string name="buildersCase1Action1">Запущена родительская корутина билдером launch</string>
    <string name="buildersCase1Action2">Запущена дочерняя корутина билдером async</string>
    <string name="buildersCase1Action3">Дочерняя корутина завершена</string>
    <string name="buildersCase1Action4">Это возвращенный результат</string>
    <string name="buildersCase1Action5">Родительская корутина, ждем пока дочерняя вернет результат</string>
    <string name="buildersCase1Action6">Дочерняя корутина вернула: %1$s</string>
    <string name="buildersCase1Action7">Завершена родительская корутина</string>
    <string name="buildersCase2Title">По кнопке А создается родительская корутина с двумя дочерними, родительская не дожидается выполнения дочерних. По кнопке Б условия те же, но родительская корутина дожидается завершения дочерних и только потом продолжается.</string>
    <string name="buildersCase2ButtonA">Создать корутины под кейс А</string>
    <string name="buildersCase2ButtonB">Создать корутины под кейс Б</string>
    <string name="buildersCase2Action1">Стартовала родительская корутина</string>
    <string name="buildersCase2Action2">Стартовала дочерняя корутина А</string>
    <string name="buildersCase2Action3">Закончилась дочерняя корутина А</string>
    <string name="buildersCase2Action4">Стартовала дочерняя корутина Б</string>
    <string name="buildersCase2Action5">Закончилась дочерняя корутина Б</string>
    <string name="buildersCase2Action6">Закончилась родительская корутина</string>
    <string name="buildersCase2Action7">Родительская корутина, ждем дочерние</string>
    <string name="buildersCase3Title">В кейсе А запускаем дочерние корутины async билдером, дожидаемся родительской корутиной завершения работы. Во кейсе Б последовательно вызываем суспенд функции и дожидаемся результата в родительской корутине. В кейсе С параллельно вызываем суспенд функции и дожидаемся результата в родительской корутине.</string>
    <string name="buildersCase3ButtonA">Кейс А</string>
    <string name="buildersCase3ButtonB">Кейс Б</string>
    <string name="buildersCase3ButtonC">Кейс C</string>
    <string name="buildersCase3Action1">Стартовала родительская корутина</string>
    <string name="buildersCase3Action2">Стартовала дочерняя корутина А</string>
    <string name="buildersCase3Action3">Закончилась дочерняя корутина А</string>
    <string name="buildersCase3Action4">Стартовала дочерняя корутина Б</string>
    <string name="buildersCase3Action5">Закончилась дочерняя корутина Б</string>
    <string name="buildersCase3Action6">Закончилась родительская корутина, результат двух дочерних: %1$s</string>
    <string name="buildersCase3Action7">Результат первой корутины</string>
    <string name="buildersCase3Action8">Результат второй корутины</string>
    <string name="buildersCase3Action9">Родительская корутина, результат дочерних: %1$s</string>
    <string name="buildersCase3Action10">Завершилась родительская корутина в %1$s</string>
    <string name="buildersCase3Action11">Результат А</string>
    <string name="buildersCase3Action12">Результат Б</string>
    <string name="buildersCase3Action13">Суспенд функция А стартанула в %1$s</string>
    <string name="buildersCase3Action14">Суспенд функция А завершилась в %1$s</string>
    <string name="buildersCase3Action15">Суспенд функция Б стартанула в %1$s</string>
    <string name="buildersCase3Action16">Суспенд функция Б завершилась в %1$s</string>
    <string name="buildersCase4Title">Корутины можно стартовать отложенно.</string>
    <string name="buildersCase4DescLaunch">Билдер launch</string>
    <string name="buildersCase4DescAsync">Билдер async</string>
    <string name="buildersCase4ButtonCreate">Создать корутину</string>
    <string name="buildersCase4ButtonStart">Стартануть корутину</string>
    <string name="buildersCase4Action1">Создаем корутину</string>
    <string name="buildersCase4Action2">Метод создания корутины завершен</string>
    <string name="buildersCase4Action3">Корутина стартовала</string>
    <string name="buildersCase4Action4">Корутина закончилась</string>
    <string name="buildersCase4Action5">Завершили запуск созданной корутины</string>
    <string name="buildersCase4Action6">Сейчас стартанем ранее созданную корутину</string>
    <string name="flowsCase1Title">Создаем самый обычный флоу, подписываем несколько подписчиков. Видим что под каждого подписчика создается свой флоу. Флоу 1 раз в секунду будет выдавать 1 элемент, всего элементов 10.</string>
    <string name="flowsCase1ButtonCreate">Создать флоу</string>
    <string name="flowsCase1ButtonFirstSub">Подписать первого подписчика</string>
    <string name="flowsCase1ButtonSecondSub">Подписать второго подписчика</string>
    <string name="flowsCase1ButtonThirdSub">Подписать третьего подписчика</string>
    <string name="flowsCase1Action1">Подписка %1$d, элемент %2$d</string>
    <string name="flowsCase2Title">Создаем самый обычный флоу с помощью asFlow (принимает коллекцию), подписываем несколько подписчиков. Видим что под каждого подписчика создается свой флоу. Флоу 1 раз в секунду будет выдавать 1 элемент, всего элементов 10.</string>
    <string name="flowsCase3Title">Создаем самый обычный флоу с помощью flowOf (принимает варарг), подписываем несколько подписчиков. Видим что под каждого подписчика создается свой флоу. Флоу 1 раз в секунду будет выдавать 1 элемент, всего элементов 10.</string>
    <string name="flowsCase4Title">Создаем самый обычный флоу с помощью функции, которая возвращает результат. Функция генерирует случайное число и возвращает его.</string>
    <string name="flowsCase4Button">Подписаться</string>
    <string name="flowsCase5Title">Каждая кнопка будет создавать флоу, через секунду подписывать на него подписчика и на каждой кнопке будет свой intermediate оператор для изменения потока данных. Список с кнопками листается вниз. В каждом флоу 10 элементов - 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 и a, b, c, d, e, f, g, h, i, j</string>
    <string name="flowsCase5ButtonMap">map</string>
    <string name="flowsCase5ButtonFilter">filter</string>
    <string name="flowsCase5ButtonTake">take</string>
    <string name="flowsCase5ButtonZip">zip</string>
    <string name="flowsCase5ButtonCombine">combine</string>
    <string name="flowsCase5ButtonWithIndex">withIndex</string>
    <string name="flowsCase5ButtonScan">scan</string>
    <string name="flowsCase5ButtonDebounce">debounce</string>
    <string name="flowsCase5ButtonDistinctUntilChanged">distinctUntilChanged</string>
    <string name="flowsCase5ButtonDrop">drop</string>
    <string name="flowsCase5ButtonSample">sample</string>
    <string name="flowsCase5TVMap">map применяет к элементам потока функцию преобразования.</string>
    <string name="flowsCase5TVFilter">filter фильтрует поток, оставляя те элементы, которые соответствуют условию.</string>
    <string name="flowsCase5TVTake">take выбирает из потока определенное количество элементов.</string>
    <string name="flowsCase5TVZip">zip из двух потоков создает один, применяя к их элементам функцию преобразования.</string>
    <string name="flowsCase5TVCombine">combine объединяет два потока в один, после применения к их элементам функции преобразования.</string>
    <string name="flowsCase5TVWithIndex">withIndex оборачивает флоу в IndexedValue, в результате каждый элемент становится парой с индексом, индекс начинается с 0.</string>
    <string name="flowsCase5TVDebounce">debounce возвращает флоу, который выпускает самое последнее значение за указанный промежуток времени.</string>
    <string name="flowsCase5TVScan">scan связывает флоу с операцией, выдавая каждый промежуточный результат, считая начальное значение</string>
    <string name="flowsCase5TVDistinctUntilChanged">distinctUntilChange возвращает флоу, в котором следующее значение идет, только если оно отличается от предыдущего</string>
    <string name="flowsCase5TVDrop">drop исключает из начала потока определенное количество значений и возвращает полученный поток.</string>
    <string name="flowsCase5TVSample">sample даст только последний элемент за указанный период времени.</string>
    <string name="flowsCase5Action1">Элементы закончились</string>
    <string name="flowsCase5Action2">Каждый элемент флоу будет умножем на 10 в операторе map</string>
    <string name="flowsCase5Action3">Полученный элемент после map: %1$d</string>
    <string name="flowsCase5Action4">С помощью filter отфильтруются только четные элементы</string>
    <string name="flowsCase5Action5">Полученный элемент после filter: %1$d</string>
    <string name="flowsCase5Action6">С помощью take возьмутся только первые 5 элементов</string>
    <string name="flowsCase5Action7">Полученный элемент после take: %1$d</string>
    <string name="flowsCase5Action8">С помощью zip склеим попарно элементы двух флоу</string>
    <string name="flowsCase5Action9">Полученный элемент после zip: %1$s</string>
    <string name="flowsCase5Action10">С помощью combine склеим попарно элементы двух флоу</string>
    <string name="flowsCase5Action11">Полученный элемент после combine: %1$s</string>
    <string name="flowsCase5Action12">С помощью withIndex узнаём индексы элементов</string>
    <string name="flowsCase5Action13">Полученный элемент после withIndex: %1$s</string>
    <string name="flowsCase5Action14">С помощью scan аккумулируют все элементы флоу и в этом примере мы получаем сумму этих элементов</string>
    <string name="flowsCase5Action15">Полученный элемент после scan: %1$d</string>
    <string name="flowsCase5Action16">debounce отбивает все значения, которые приходят чаще чем указанное временное окно. В этом примере первый элемент эмитится сразу, затем после задержки в 1 сек второй, затем после задержки в 4 секунды всё повторяется</string>
    <string name="flowsCase5Action17">Полученный элемент после debounce: %1$d</string>
    <string name="flowsCase5Action18">С помощью distinctUntilChanged передаем значение только если оно отличается от предыдущего. В этом примере используется список типа 112233..</string>
    <string name="flowsCase5Action19">Полученный элемент после distinctUntilChanged: %1$d</string>
    <string name="flowsCase5Action20">С помощью drop отбрасываем первые 5 элементов</string>
    <string name="flowsCase5Action21">Полученный элемент после drop: %1$d</string>
    <string name="flowsCase5Action22">С помощью sample получаем последний элемент в окне 3 секунд</string>
    <string name="flowsCase5Action23">Полученный элемент после sample: %1$d</string>
    <string name="flowsCase6Title">Создаем свой оператор, который будет превращать любой текст в текст в верхнем регистре.</string>
    <string name="flowsCase6Button">Создать флоу и подписаться</string>
    <string name="flowsCase6Action1">"Выпущен элемент - %1$s</string>
    <string name="flowsCase7Title">Создаем флоу, эмитим \'1\', затем с помощью emitAll() встраиваем все элементы другого флоу, из которого с разницей в 1 сек заэмитятся 10 букв, затем продолжаем этот флоу, который завершится на элементе \'2\'</string>
    <string name="flowsCase7Button">Старт</string>
    <string name="flowsCase8ButtonCollect">collect</string>
    <string name="flowsCase8TVCollect">Используется для сбора и обработки результатов флоу. Ожидает, пока все значения, производимые в рамках этой корутины будут получены, и затем возвращает список этих значений. При этом блокирует выполнение текущей корутины до тех пор, пока все значения не будут получены.</string>
    <string name="flowsCase8ButtonSingle">single</string>
    <string name="flowsCase8TVSingle">Ждет только одно значение от флоу. Бросает NuSuchElementException если флоу пустой и IllegalArgumentException если значений больше одного.</string>
    <string name="flowsCase8ButtonReduce">reduce</string>
    <string name="flowsCase8TVReduce">Каким-то образом агрегирует полученные от флоу данные.</string>
    <string name="flowsCase8ButtonCount">count</string>
    <string name="flowsCase8ButtonFirst">first</string>
    <string name="flowsCase8ButtonToList">toList</string>
    <string name="flowsCase8ButtonToSet">toSet</string>
    <string name="flowsCase8ButtonFold">fold</string>
    <string name="flowsCase8TVCount">Оператор count позволяет применить какой-то предикат к элементам флоу и посчитать количество элементов, которые ему удовлетворяют</string>
    <string name="flowsCase8TVFirst">Получает только первое значение флоу и затем отменяет его.</string>
    <string name="flowsCase8TVToList">Перегоняет элементы флоу в лист</string>
    <string name="flowsCase8TVToSet">Перегоняет элементы флоу в сет</string>
    <string name="flowsCase8TVFold">Возвращает результат операций с флоу</string>
    <string name="flowsCase8Action1">Оператор collect, полученное значение: %1$d</string>
    <string name="flowsCase8Action2">В флоу было 10 элементов с 1 по 10 и мы их все получили с помощью collect.</string>
    <string name="flowsCase8Action3">Оператор single, полученное значение: %1$d</string>
    <string name="flowsCase8Action4">Оператор reduce, полученное значение: %1$d</string>
    <string name="flowsCase8Action5">Как работает - производит операции над accumulator и value начиная с первого элемента флоу, сохраняет результат, затем берет уже результат и производит операцию со следующим элементом флоу, и так пока флоу не закончится.</string>
    <string name="flowsCase8Action6">В этом примере флоу состоит из цифр с 1 по 10 включительно, в самом начале 1 умножается на 2, получается два, следующий элемент - 3, поэтому 2 умножается на 3, получается 6. Следующий элемент - 4, умножается на 6, получается 24. И так далее.</string>
    <string name="flowsCase8Action7">Операция reduce является терминальной, то есть выполняется когда элементы флоу закончились, поэтому промежуточные значения accumulator увидеть нельзя.</string>
    <string name="flowsCase8Action8">Слова в массиве: %1$s</string>
    <string name="flowsCase8Action9">Оператор count отфильтрует из списка только те слова, чья длина >4</string>
    <string name="flowsCase8Action10">Оператор count, полученное значение: %1$d</string>
    <string name="flowsCase8Action11">Флоу содержит элементы: 1, 2, 3, 4, 5</string>
    <string name="flowsCase8Action12">Оператор first, полученное значение: %1$d</string>
    <string name="flowsCase8Action13">Слова в массиве: %1$s</string>
    <string name="flowsCase8Action14">Применяем оператор toList</string>
    <string name="flowsCase8Action15">Оператор toList, полученное значение из списка: %1$s</string>
    <string name="flowsCase8Action16">Перегнали значения флоу в лист</string>
    <string name="flowsCase8Action17">Слова в массиве: %1$s</string>
    <string name="flowsCase8Action18">Применяем оператор toSet</string>
    <string name="flowsCase8Action19">Оператор toSet, полученное значение из сета: %1$s</string>
    <string name="flowsCase8Action20">Перегнали значения флоу в сет</string>
    <string name="flowsCase8Action21">Оператор fold, промежуточное значение accumulator: %1$d</string>
    <string name="flowsCase8Action22">Оператор fold, итоговое значение: %1$d</string>
    <string name="flowsCase8Action23">fold позволяет выполнить преобразования с аккумулированным значением и каждым элементом флоу, при этом мы задаем стартовое значение в конструкторе. В отличие от reduce можем узнать промежуточные значения accumulator, что и видно в этом примере.</string>
    <string name="flowsCase9Title">Создадим 4 разных флоу и в каждом используем intermediate операторы, не рассмотренные ранее. Как и с остальными intermediate операторами, они могут работать в цепочке.</string>
    <string name="flowsCase9ButtonOnEach">onEach</string>
    <string name="flowsCase9ButtonOnStart">onStart</string>
    <string name="flowsCase9ButtonOnCompletion">onCompletion</string>
    <string name="flowsCase9ButtonOnEmpty">onEmpty</string>
    <string name="flowsCase9ButtonEach">Все кроме onEmpty</string>
    <string name="flowsCase9Action1">Вызвался onStart, элемент нам тут недоступен</string>
    <string name="flowsCase9Action2">Вызвался onEach на элементе %1$s</string>
    <string name="flowsCase9Action3">Вызвался onCompletion, тут нам доступен throwable: %1$s</string>
    <string name="flowsCase9Action4">Элемент флоу: %1$s</string>
    <string name="flowsCase9Action5">Вызвался onEmpty, тут нам ничего не доступно</string>
    <string name="flowsCase9Action6">Здесь с помощью onEach мы каждый раз добавляли запись в лог перед тем как вывести в лог сам элемент</string>
    <string name="flowsCase9Action7">Здесь с помощью onStart мы вывели в лог момент начала работы флоу</string>
    <string name="flowsCase9Action8">Здесь с помощью onCompletion мы вывели в лог момент конца работы флоу, указав throwable. Если бы была реальная ошибка, могли бы с ней что-то сделать</string>
    <string name="flowsCase9Action9">Здесь с помощью onEmpty мы вывели в лог запись в случае когда флоу пустой</string>
    <string name="flowsCase9Action10">Здесь мы просто скомбинировали все операторы кроме onEmpty</string>
    <string name="flowsCase10Title">Создаем channelFlow. В трех параллельных корутинах он будет эмиттить по элементу, каждая корутина ждет на 1 секунду дольше чем предыдущая прежде чем выпустить значение.</string>
    <string name="flowsCase10Button">Создать</string>
    <string name="flowsCase10Action1">Получили элемент %1$d</string>
    <string name="flowsCase10Action2">С помощью channelFlow можно собирать элементы из разных корутин и под капотом они будут передаваться в ту корутину, которая обрабатывает collect</string>
    <string name="flowsCase11Title">Работа callbackFlow на примере editText. Если уйти с экрана или написать close, сработает колбек</string>
    <string name="flowsCase11Hint">Тут надо начать чето писать</string>
    <string name="flowsCase11Action1">Сработал awaitClose, т.к. флоу отменили</string>
    <string name="flowsCase11Action2">Это получили из флоу: %1$s</string>
    <string name="flowsCase12Title">Работа оператора flowOn, который меняет потоки. Работает на предыдущие операторы.</string>
    <string name="flowsCase12Button">Создать флоу</string>
    <string name="flowsCase12Action1">Поток до создания флоу - %1$s</string>
    <string name="flowsCase12Action2">Поток в onEach в ио, элемент из флоу - %1$d, поток -  %2$S</string>
    <string name="flowsCase12Action3">Поток в onEach после фильтра в мейне, элемент из флоу - %1$d, поток - %2$s</string>
    <string name="flowsCase12Action4">Поток в onEach после мапы после flowOn, спереди flowOn больше нет, значит мейн, элемент из флоу - %1$s, поток - %2$s</string>
    <string name="flowsCase12Action5">Финальный элемент из флоу из блока коллект - %1$s, поток - %2$s</string>
    <string name="flowsCase13Title">Работа оператора buffer</string>
    <string name="flowsCase13Button">Создать флоу</string>
    <string name="flowsCase13Action1">Элемент - %1$d, время - %2$s</string>
    <string name="flowsCase13Action2">В флоу цифры с 1 по 10. Размер буфера установлен в 2, используется стратегия работы с переполнением BufferOverflow.DROP_OLDEST. Поэтому мы получаем первый элемент, и из-за того что в блоке коллект обрабатывается не больше 1 элемента в секунду и мы используем буфер со стратегией замены старых значений получает в итоге первое и два последних значения этого флоу.</string>
    <string name="flowsCase14Title">Работа оператора produceIn. Создается канал, который сразу начинает свою работу, не дожидаясь подписчиков</string>
    <string name="flowsCase14Button">Создать канал</string>
    <string name="flowsCase14Action1">Из созданного с помощью produceIn канала получен элемент %1$d</string>
    <string name="flowsCase15Title">Работа оператора catch.</string>
    <string name="flowsCase15Button">Запустить пример</string>
    <string name="flowsCase15Action1">Сработал оператор catch, поймана ошибка: %1$s</string>
    <string name="flowsCase15Action2">Получен элемент %1$d</string>
    <string name="flowsCase15Action3">catch ловит ошибки только на коде до catch. Так же можно использовать несколько catch при необходимости в одной цепочке. Корутина отменяется при любой ошибке</string>
    <string name="flowsCase16Title">Работа оператора retry.</string>
    <string name="flowsCase16Button">Запустить пример</string>
    <string name="flowsCase16Action1">Результат деления 100 на элемент: %1$d</string>
    <string name="flowsCase16Action2">retry сработает 2 раза, затем ошибка пойдет дальше, но будет поймана оператором catch</string>
    <string name="flowsCase16Action3">Сработал retry, ошибка: %1$s</string>
    <string name="flowsCase16Action4">retry сработал %1$d раз</string>
    <string name="flowsCase16Action5">Поймана ошибка: %1$s</string>
    <string name="flowsCase17Title">Работа оператора retryWhen.</string>
    <string name="flowsCase17Button">Запустить пример</string>
    <string name="flowsCase17Action1">retryWhen будет работать, пока количество попыток будет меньше 2</string>
    <string name="flowsCase17Action2">Поймана ошибка: %1$s</string>
    <string name="flowsCase17Action3">Результат деления 100 на элемент: %1$d</string>
    <string name="flowsCase17Action4">Блок retryWhen, ошибка - %1$s, попытка - %2$d</string>
    <string name="flowsCase18Title">Проверяем что если в корутине есть код после вызова collect, который надо чтоб отработал даже при отмене корутины, то можно обернуть вызов collect в try-catch .</string>
    <string name="flowsCase18ButtonWTryCatch">Запустить пример с try-catch</string>
    <string name="flowsCase18ButtonWOTryCatch">Запустить пример без try-catch</string>
    <string name="flowsCase18Action1">Получен элемент списка %1$d</string>
    <string name="flowsCase18Action2">Флоу будет выдавать по порядку: 1, 2, 3, 4, 5. На числе "3" корутина будет отменена. Мы должны будем увидеть сообщение из кода после блока коллект.</string>
    <string name="flowsCase18Action3">Блок catch, поймана ошибка: %1$s</string>
    <string name="flowsCase18Action4">Код после try-catch, в который обернут блок collect</string>
    <string name="flowsCase19Title">Верхняя кнопка эмитит в шаредфлоу, нижняя подписывает на него. Шаредфлоу создан с параметром replay = 2, то есть каждый новый подписчик будет получать последние 2 значения.</string>
    <string name="flowsCase19ButtonEmit">Отправить данные</string>
    <string name="flowsCase19ButtonSubscribe">Вызвать collect</string>
    <string name="flowsCase19Action1">Получен элемент %1$d, тред - %2$s</string>
    <string name="flowsCase20Title">На каждое нажатие кнопки подписываем на стейтфлоу подписчика. Видим что стейтфлоу выдает одно и то же для всех подписчиков, а когда подписываемся на уже закончившийся флоу то получаем последнее значение</string>
    <string name="flowsCase20Button">Запустить пример</string>
    <string name="flowsCase20Action1">Получен элемент %1$d, тред - %2$s</string>
    <string name="flowsCase21Title">Проверяем параметр started при создании шаредфлоу оператором shareIn</string>
    <string name="flowsCase21ButtonE">started - Eagerly. Работа начинается даже если нет подписчиков</string>
    <string name="flowsCase21ButtonL">started - Lazily. Стартует при появлении первого подписчика. Будет работать пока не отменим scope</string>
    <string name="flowsCase21ButtonW">started - WhileSubscribed. Стартует при появлении первого подписчика. При уходе последнего подписчика - останавливается</string>
    <string name="flowsCase21Action1">Параметры шаредфлоу - replay = 0. Элементы с 1 по 10. Каждый элемент выпускается после задержки в .5 сек. Подписываемся только через 3 сек. Увидим что флоу начал работу пока подписчика еще не было</string>
    <string name="flowsCase21Action2">Получен элемент %1$d</string>
    <string name="flowsCase21Action3">Параметры шаредфлоу - replay = 0. Элементы с 1 по 10. Каждый элемент выпускается после задержки в .5 сек. Подписываемся через 1, 2 и 3 сек. На 8 элементе первого подписчика скоуп будет отменен и флоу прекратит работу для всех подписчиков.</string>
    <string name="flowsCase21Action4">Первый подписчик, получен элемент %1$d</string>
    <string name="flowsCase21Action5">Второй подписчик, получен элемент %1$d</string>
    <string name="flowsCase21Action6">Третий подписчик, получен элемент %1$d</string>
    <string name="flowsCase21Action7">Четвертый подписчик, получен элемент %1$d</string>
    <string name="flowsCase21Action8">Параметры шаредфлоу - replay = 0. Элементы с 1 по 10. Каждый элемент выпускается после задержки в .5 сек. Подписываемся через 1, 2 и 3 сек. На 5 элементе флоу эти 3 подписчика отпишутся. Но у флоу задан параметр ожидания 2 секунды прежде чем отменяться, за эти 2 секунды подпишется четвертый подписчик, получит 1 элемент и отпишется.</string>
    <string name="flowsCase22Title">У нас есть MutableSharedFlow, который выдает с задержкой 0.5 сек числа от 1 до 10. После нажатия на кнопку с интервалом в 1 секунду подпишутся 3 подписчика, после каждой подписки увидим что выдает subscriptionCount. Его можно использовать для логики. Количество подписчиков выводится в лог перед тем, как подпишется следующий, поэтому там на 1 меньше вот сейчас станет.</string>
    <string name="flowsCase22Button">Запустить пример</string>
    <string name="flowsCase22Action1">Количество подписчиков - %1$d</string>
    <string name="flowsCase22Action2">Первый подписчик, получен элемент %1$d</string>
    <string name="flowsCase22Action3">Второй подписчик, получен элемент %1$d</string>
    <string name="flowsCase22Action4">Третий подписчик, получен элемент %1$d</string>
    <string name="flowsCase23Title">В этом примере проверяем стратегии при переполнении буфера. Элементов всего будет 50. Флоу будет генерировать элементы каждые 0.5 сек. Первый подписчик будет обрабатывать их с такой же скоростью, второй со скоростью элемент в 1 сек, третий со скоростью элемент в 2 сек. Всего будет 50 элементов, буфер будет на 10 элементов. SUSPEND будет приостанавливать корутины, пока не появятся свободные слоты в буфере. DROP_OLDEST будет удалять из буфера наиболее старые элементы. До медленных получателей дойдут не все данные. DROP_LATEST не будет отправлять новые значения, пока буфер заполнен, все получатели будут пропускать новые данные, если медленные получатели все еще обрабатывают старые данные.</string>
    <string name="flowsCase23ButtonSus">SUSPEND</string>
    <string name="flowsCase23ButtonOld">DROP_OLDEST</string>
    <string name="flowsCase23ButtonLat">DROP_LATEST</string>
    <string name="flowsCase23Action1">Первый подписчик, получен элемент %1$d</string>
    <string name="flowsCase23Action2">Второй подписчик, получен элемент %1$d</string>
    <string name="flowsCase23Action3">Третий подписчик, получен элемент %1$d</string>
    <string name="flowsCase24Title">В этом примере будет буфер с разным объемом. Элементов всего будет 25. После заполнения буфера будет использоваться стратегия SUSPEND. Флоу эмитит каждые 0.5 сек, первый подписчик обрабатывает их с такой же скоростью, второй за одну секунду, третий за две секунды.</string>
    <string name="flowsCase24ButtonFive">Размер 5</string>
    <string name="flowsCase24ButtonTen">Размер 10</string>
    <string name="flowsCase24ButtonTwenty">Размер 20</string>
    <string name="flowsCase24Action1">Первый подписчик, получен элемент %1$d</string>
    <string name="flowsCase24Action2">Второй подписчик, получен элемент %1$d</string>
    <string name="flowsCase24Action3">Третий подписчик, получен элемент %1$d</string>
    <string name="flowsCase25Title">В этом примере будет использован параметр replay с разным объемом. Он отличается от буфера из предыдущего примера тем, что включает кэш. В кеше всегда что-то есть, а вот буфер может быть пустым. В этом примере этого нет, но можно одновременно использовать и то и то, тогда кеш увеличится на размер буфера, то есть при значениях 5 и там и там мы сможем иметь общий запас в 10 элементов. Элементов всего будет 25. После заполнения буфера будет использоваться стратегия SUSPEND. Флоу эмитит каждые 0.5 сек, первый подписчик обрабатывает их с такой же скоростью, второй за одну секунду, третий за две секунды.</string>
    <string name="flowsCase25ButtonFive">Размер 5</string>
    <string name="flowsCase25ButtonTen">Размер 10</string>
    <string name="flowsCase25ButtonTwenty">Размер 20</string>
    <string name="flowsCase25Action1">Первый подписчик, получен элемент %1$d</string>
    <string name="flowsCase25Action2">Второй подписчик, получен элемент %1$d</string>
    <string name="flowsCase25Action3">Третий подписчик, получен элемент %1$d</string>
    <string name="operatorsCase1Title">Оператор select возвращает результат той корутины, что отработала быстрее остальных. В этом примере будут одновременно запущены две async корутины, первая возвращает значение 1 через 2 сек, вторая значение 2 через 3 сек. В результате увидим только то что сработало быстрее.</string>
    <string name="operatorsCase1Button">Запустить пример</string>
    <string name="operatorsCase1Action1">Первая асинк пошла</string>
    <string name="operatorsCase1Action2">Первая синк завершилась и вернула результат</string>
    <string name="operatorsCase1Action3">Вторая асинк пошла</string>
    <string name="operatorsCase1Action4">Вторая синк завершилась и вернула результат, но это нам уже без разницы</string>
    <string name="operatorsCase1Action5">Получен результат от корутины %1$d</string>
</resources>