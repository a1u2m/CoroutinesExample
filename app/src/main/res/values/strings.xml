<resources>
    <string name="app_name">CoroutinesExample</string>
    <string name="logTitle">Лог</string>
    <string name="loClearButton">Очистить</string>
    <string name="buttonGo">Перейти</string>
    <string name="autoscrollOn">Выкл автоскролл</string>
    <string name="autoscrollOff">Вкл автоскролл</string>
    <string name="openExample">Открыт пример: %1$s</string>
    <string name="quitExample">Закрыт пример: %1$s</string>
    <string name="titleDispatchers">Диспетчеры</string>
    <string name="dispatchersCase1">Дефолтный диспетчер. Смотрим какой диспетчер создается без явного указания диспетчера</string>
    <string name="dispatchersCase2">Дефолтный диспетчер. Смотрим сколько максимум одновременных потоков может быть при использовании дефолтного диспетчера</string>
    <string name="dispatchersCase3">IO диспетчер. Смотрим сколько максимум одновременных потоков может быть при использовании IO диспетчера</string>
    <string name="dispatchersCase4">Создание собственного диспетчера с одним потоком</string>
    <string name="dispatchersCase5">Unconfined диспетчер. Особенности работы</string>
    <string name="titleErrors">Ошибки</string>
    <string name="errorsCase1">Отмена скоупа и всех дочерних корутин при ошибке внутри try-catch внутри дочерней корутины</string>
    <string name="errorsCase2">Обработчик ошибок вместо try-catch</string>
    <string name="errorsCase3">Обработчик ошибок + SupervisorJob в скоупе</string>
    <string name="errorsCase4">Обработчик ошибок + SupervisorJob в корутине. Несколько корутин на одном уровне</string>
    <string name="errorsCase5">Билдер launch + async корутина + await. Проверка что не выполняется код после await при возникновении ошибки</string>
    <string name="errorsCase6">Билдер launch + async корутина + await. Используем try-catch, проверяем что после await при возникновении ошибки код выполняется</string>
    <string name="errorsCase7">Ошибка в suspend функции корутины. Try-catch</string>
    <string name="titleBuilders">Билдеры</string>
    <string name="buildersCase1">Билдер async. Получаем результат методом await</string>
    <string name="buildersCase2">Билдер launch. Запуск дочерних корутин так, чтобы родительская не дожидалась их завершения и так, чтобы дожидалась.</string>
    <string name="buildersCase3">Билдер async. Запуск дочерних корутин с получением от них результата, параллельный запуск.</string>
    <string name="buildersCase4">Билдер async. Ленивый старт методом await</string>
    <string name="titleSuspend">Suspend функции</string>
    <string name="suspendCase1">Проверяем то что suspend функция не блокирует поток</string>
    <string name="titleCoroutines">Корутины</string>
    <string name="coroutinesCase1">ЖЦ корутины</string>
    <string name="coroutinesCase2">Неправильная отмена корутины</string>
    <string name="coroutinesCase3">Правильная отмена корутины</string>
    <string name="coroutinesCase4">Дожидаемся выполнения корутины с помощью join</string>
    <string name="coroutinesCase5">Параллельная работа внутри родительской корутины с использованием join</string>
    <string name="coroutinesCase6">Ленивое создание корутины</string>
    <string name="coroutinesCase7">Отмена корутины + invokeOnCancellation</string>
    <string name="coroutinesCase8">Используем NonCancellableJob</string>
    <string name="coroutinesCase9">Параллельный запуск корутин</string>
    <string name="coroutinesCase10">Работа с одной переменной разными способами</string>
    <string name="coroutinesCase11">Наследование в корутинах</string>
    <string name="coroutinesCase12">Защита от повторных вызовов с помощью Job</string>
    <string name="coroutinesCase13">Проверяем что родительская корутина ждет завершения дочерней</string>
    <string name="titleScope">Скоуп</string>
    <string name="scopeCase1">Отмена скоупа вместе с его корутинами</string>
    <string name="scopeCase2">Создаем иерархию корутин и отменяем их по-разному, смотрим что происходит</string>
    <string name="scopeCase3">Создаем свой объект и добавляем его в контекст скоупа</string>
    <string name="scopeCase4">Проверяем что контекст передается корутинам по наследству + меняем контекст при создании дочерней корутины</string>
    <string name="titleScopeFunctions">Скоуп функции</string>
    <string name="scopeFunctionsCase1">Создаем и отменяем корутины</string>
    <string name="scopeFunctionsCase2">Создаем и отменяем корутины + SupervisorScope</string>
    <string name="scopeFunctionsCase3">Используем withContext для замены контекста</string>
    <string name="scopeFunctionsCase4">Используем runBlocking чтобы заблокировать поток</string>
    <string name="scopeFunctionsCase5">Используем viewmodelScope</string>
    <string name="scopeFunctionsCase6">Используем lifecycleScope</string>
    <string name="scopeFunctionsCase7">Используем mainScope</string>
    <string name="scopeFunctionsCase8">Создаем свой скоуп</string>
    <string name="titleChannels">Каналы</string>
    <string name="channelsCase1">Самое просто использование канала. Одной корутиной складываем, второй достаем</string>
    <string name="channelsCase2">Складываем в канал больше чем могут получить</string>
    <string name="channelsCase3">Складываем в канал меньше чем могут получить</string>
    <string name="channelsCase4">Закрываем канал и ловим ексепшн от этого</string>
    <string name="channelsCase5">Заворачиваем получение из канала в цикл, смотрим что получится</string>
    <string name="channelsCase6">Закрываем канал и используем isClosedForReceive</string>
    <string name="channelsCase7">Увеличиваем размер канала через capacity</string>
    <string name="channelsCase8">Увеличиваем размер канала через Channel.Factory.CONFLATED</string>
    <string name="channelsCase9">Отменяем канал</string>
    <string name="channelsCase10">Отменяем корутину, но не канал</string>
    <string name="channelsCase11">Закрываем канал при отмене корутины через колбек invokeOnCompletion</string>
    <string name="channelsCase12">Используем канал несколькими корутинами</string>
    <string name="channelsCase13">Пробуем слать в канал через trySend</string>
    <string name="titleFlow">Флоу</string>
    <string name="flowCase1">Создаем стандартный флоу, проверяем холодность</string>
    <string name="flowCase2">Создаем стандартный флоу через asFlow</string>
    <string name="flowCase3">Создаем стандартный флоу через flowOf</string>
    <string name="flowCase4">Создаем стандартный флоу через ::suspend fun</string>
    <string name="flowCase5">Создаем свой флоу под многие из intermediate операторов</string>
    <string name="flowCase6">Создаем свой оператор</string>
    <string name="flowCase7">Смотрим что делает метод emitAll</string>
    <string name="flowCase8">Создаем свой флоу под многие из terminal операторов</string>
    <string name="flowCase9">Создаем свой флоу под onEach, onStart, onCompletion, onEmpty</string>
    <string name="flowCase10">Создаем channelFlow</string>
    <string name="flowCase11">Создаем callbackFlow</string>
    <string name="flowCase12">Используем оператор flowOn</string>
    <string name="flowCase13">Используем оператор buffer</string>
    <string name="flowCase14">Используем оператор produceIn</string>
    <string name="flowCase15">Используем оператор catch</string>
    <string name="flowCase16">Используем оператор retry</string>
    <string name="flowCase17">Используем оператор retryWhen</string>
    <string name="flowCase18">Отмена флоу + try-catch</string>
    <string name="flowCase19">Создаем SharedFlow</string>
    <string name="flowCase20">Создаем StateFlow</string>
    <string name="flowCase21">Проверяем параметры shareIn у SharedFlow</string>
    <string name="flowCase22">Проверяем параметры subscriptionCount у SharedFlow</string>
    <string name="flowCase23">Проверяем режимы работы onBufferOverflow у SharedFlow</string>
    <string name="flowCase24">Проверяем параметр extraBufferCapacity у SharedFlow</string>
    <string name="flowCase25">Проверяем параметр replay у SharedFlow</string>
    <string name="flowCase26">Проверяем что корутина приостанавливается пока ждет следующий элемент флоу</string>
    <string name="titleOperators">Операторы</string>
    <string name="operatorsCase1">Используем оператор select</string>
    <string name="operatorsCase2">Используем оператор actor</string>
    <string name="dispatchersCase1WithoutDispatcherDesc">Скоуп создан без указания диспетчера, используется диспетчер по умолчанию (DEFAULT), видим что используются треды DefaultDispatcher</string>
    <string name="dispatchersCase1WithDispatcherDesc">Скоуп создан с указанием main диспетчера, видим что используется main тред</string>
    <string name="dispatchersCase1Action1">Скоуп создан</string>
    <string name="dispatchersCase1Action2">Запущена корутина в скоупе</string>
    <string name="dispatchersCase1Action3">Содержимое контекста скоупа: %1$s</string>
    <string name="dispatchersCase1Action4">Текущий тред: %1$s</string>
    <string name="dispatchersCase1Title">Если при создании корутины или скоупа диспетчер не указан, то используется дефолтный.</string>
    <string name="dispatchersCase1ButtonWithout">Создать скоуп без указания диспетчера</string>
    <string name="dispatchersCase1ButtonWith">Создать скоуп с диспетчером Main</string>
    <string name="dispatchersCase2Title">Создаем одновременно 20 корутин с Default диспетчером. Потоков будет столько, сколько ядер на устройстве (считая виртуальные). Каждая корутина будет делать ⅓ от своей работы за 2 секунды, и выполнив всю работу на 100% завершаться. Так будет повторяться, пока не выполнят свою работу все 20 корутин.</string>
    <string name="dispatchersCase2Button">Создать одновременно 20 корутин</string>
    <string name="dispatchersCase2Action1">Корутина %1$d запущена в треде %2$s в %3$s</string>
    <string name="dispatchersCase2Action2">Корутина %1$d сделала 1/3 работы в треде %2$s в %3$s</string>
    <string name="dispatchersCase2Action3">Корутина %1$d сделала 2/3 работы в треде %2$s в %3$s</string>
    <string name="dispatchersCase2Action4">Корутина %1$d завершена в треде %2$s в %3$s</string>
    <string name="dispatchersCase2Action5">Видим, что одновременно работает ограниченное число корутин. Только после того, как поток освободится, он возьмет в работу следующую корутину.</string>
    <string name="dispatchersCase3Title">Создаем одновременно 100 корутин, смотрим сколько одновременно работает на счетчике ниже и сверяемся с логом. Каждая корутина работает 5 секунд и завершается.</string>
    <string name="dispatchersCase3Button">Создать одновременно 100 корутин</string>
    <string name="dispatchersCase3Counter">Счетчик активных задач у джоба: </string>
    <string name="dispatchersCase3Action1">Корутина %1$d запущена в треде %2$s в %3$s</string>
    <string name="dispatchersCase3Action2">Корутина %1$d завершена в треде %2$s в %3$s</string>
    <string name="dispatchersCase3Action3">После нажатия кнопки активных задач становится 100, потому что мы одновременно создаем их 100. Но выполняется одновременно скорее всего только 64, поэтому после выполнения первой пачки счетчик меняется на 36. И последняя смена на 1 происходит из-за добавления этой текстовки, которая срабатывает по колбеку, когда у джоба заканчиваются активные задачи.</string>
    <string name="dispatchersCase4Title">Создать 5 корутин, которые будут выполняться в созданном нами диспетчере, имеющим в распоряжении только один поток. Время работы одной корутины составляет 1 секунду.</string>
    <string name="dispatchersCase4Button">Создать</string>
    <string name="dispatchersCase4Action1">Корутина %1$d запущена в треде %2$s в %3$s</string>
    <string name="dispatchersCase4Action2">Корутина %1$d завершена в треде %2$s в %3$s</string>
    <string name="dispatchersCase4Action3">Видим, что одновременно работает только одна корутина.</string>
    <string name="dispatchersCase5Title">Создаем корутину и смотрим как меняется поток выполнения при использовании диспетчера Unconfined.</string>
    <string name="dispatchersCase5ButtonMain">Создать с диспетчером мейн</string>
    <string name="dispatchersCase5ButtonUnconfined">Создать с диспетчером unconfined</string>
    <string name="dispatchersCase5Action1">Запустили корутину с Unconfined диспетчером в треде %1$s в %2$s</string>
    <string name="dispatchersCase5Action2">Запускаем суспенд функцию из корутины в треде %1$s в %2$s</string>
    <string name="dispatchersCase5Action3">Корутина завершилась в треде %1$s в %2$s</string>
    <string name="dispatchersCase5Action4">Запустилась суспенд функция в треде %1$s в %2$s</string>
    <string name="dispatchersCase5Action5">Суспенд функция подождала секунду ДО смены потока в треде %1$s в %2$s</string>
    <string name="dispatchersCase5Action6">Суспенд функция подождала секунду ПОСЛЕ смены потока на IO в треде %1$s в %2$s</string>
    <string name="dispatchersCase5Action7">Суспенд функция завершилась в треде %1$s в %2$s</string>
    <string name="dispatchersCase5Action8">Продолжение работы корутины после выполнения суспенд функции в треде %1$s в %2$s</string>
    <string name="dispatchersCase5Action9">Видим, что корутина стартует в main, так как билдер, запустивший и создавший корутину находится в нем. Далее во время выполнения суспенд функции уходим в другие потоки, а после возвращения остаемся в них же, уйдя из мейн в суспенд функции.</string>
    <string name="dispatchersCase5Action10">Видим, что корутина стартует в main (явно указали диспетчер main). Далее во время выполнения суспенд функции уходим в IO поток, а после возвращаемся в main.</string>
    <string name="dispatchersCase5Action11">Запустили корутину с Main диспетчером в треде %1$s в %2$s</string>
    <string name="suspendsCase1Title">По кнопке А запускаем суспенд функцию в мейн потоке, которая выполняет длительную работу (просто ждет 10 сек). По кнопке Б меняем UI, тем самым видим что суспенд функция не блокирует поток, а именно приостанавливает выполнение своего кода.</string>
    <string name="suspendsCase1ButtonA">Стартануть долгую суспенд функцию</string>
    <string name="suspendsCase1ButtonB">Поменять квадратик</string>
    <string name="suspendsCase1Action1">Суспенд функция стартанула в треде %1$s в %2$s</string>
    <string name="suspendsCase1Action2">Суспенд функция завершилась в треде %1$s в %2$s</string>
    <string name="buildersCase1Title">Создаем корутину билдером async и получаем результат</string>
    <string name="buildersCase1Button">Создать корутину билдером async</string>
    <string name="buildersCase1Action1">Запущена родительская корутина билдером launch</string>
    <string name="buildersCase1Action2">Запущена дочерняя корутина билдером async</string>
    <string name="buildersCase1Action3">Дочерняя корутина завершена</string>
    <string name="buildersCase1Action4">Это возвращенный результат</string>
    <string name="buildersCase1Action5">Родительская корутина, ждем пока дочерняя вернет результат</string>
    <string name="buildersCase1Action6">Дочерняя корутина вернула: %1$s</string>
    <string name="buildersCase1Action7">Завершена родительская корутина</string>
    <string name="buildersCase2Title">По кнопке А создается родительская корутина с двумя дочерними, родительская не дожидается выполнения дочерних. По кнопке Б условия те же, но родительская корутина дожидается завершения дочерних и только потом продолжается.</string>
    <string name="buildersCase2ButtonA">Создать корутины под кейс А</string>
    <string name="buildersCase2ButtonB">Создать корутины под кейс Б</string>
    <string name="buildersCase2Action1">Стартовала родительская корутина</string>
    <string name="buildersCase2Action2">Стартовала дочерняя корутина А</string>
    <string name="buildersCase2Action3">Закончилась дочерняя корутина А</string>
    <string name="buildersCase2Action4">Стартовала дочерняя корутина Б</string>
    <string name="buildersCase2Action5">Закончилась дочерняя корутина Б</string>
    <string name="buildersCase2Action6">Закончилась родительская корутина</string>
    <string name="buildersCase2Action7">Родительская корутина, ждем дочерние</string>
    <string name="buildersCase3Title">В кейсе А запускаем дочерние корутины async билдером, дожидаемся родительской корутиной завершения работы. Во кейсе Б последовательно вызываем суспенд функции и дожидаемся результата в родительской корутине. В кейсе С параллельно вызываем суспенд функции и дожидаемся результата в родительской корутине.</string>
    <string name="buildersCase3ButtonA">Кейс А</string>
    <string name="buildersCase3ButtonB">Кейс Б</string>
    <string name="buildersCase3ButtonC">Кейс C</string>
    <string name="buildersCase3Action1">Стартовала родительская корутина</string>
    <string name="buildersCase3Action2">Стартовала дочерняя корутина А</string>
    <string name="buildersCase3Action3">Закончилась дочерняя корутина А</string>
    <string name="buildersCase3Action4">Стартовала дочерняя корутина Б</string>
    <string name="buildersCase3Action5">Закончилась дочерняя корутина Б</string>
    <string name="buildersCase3Action6">Закончилась родительская корутина, результат двух дочерних: %1$s</string>
    <string name="buildersCase3Action7">Результат первой корутины</string>
    <string name="buildersCase3Action8">Результат второй корутины</string>
    <string name="buildersCase3Action9">Родительская корутина, результат дочерних: %1$s</string>
    <string name="buildersCase3Action10">Завершилась родительская корутина в %1$s</string>
    <string name="buildersCase3Action11">Результат А</string>
    <string name="buildersCase3Action12">Результат Б</string>
    <string name="buildersCase3Action13">Суспенд функция А стартанула в %1$s</string>
    <string name="buildersCase3Action14">Суспенд функция А завершилась в %1$s</string>
    <string name="buildersCase3Action15">Суспенд функция Б стартанула в %1$s</string>
    <string name="buildersCase3Action16">Суспенд функция Б завершилась в %1$s</string>
</resources>